## 3.3 Modeling with Mutable Data

recall chapter2：

数据抽象的原则，数据结构用**构造函数和选择器来指定**，构造函数创建数据对象，**选择器访问复合数据对象的各个部分**。

pair作为合成复合数据的通用“粘合剂”。



现在：

我们需要定义**可变数据类型**。

为了对状态变化的复合对象进行建模，除了选择器和构造器之外，我们还将设计数据抽象，包括称为mutator的操作，这些操作**可以修改数据对象**。

为其定义了mutator的数据对象称为**可变数据对象**。

复杂系统被建模为具有**局部状态的对象集合**。

为最基本的pair定义mutator，

**然后就可以根据这个有mutator性质的变量构造mutable data objects**





### 3.3.1 Mutable List Structure

<img src="3-3.assets/image-20240221101219203.png" alt="image-20240221101219203" style="zoom:50%;" />

```lisp
; x
(list (list a b) c d)
; y
(list e f)
```



下面为pair添加两个新的过程：

**（1）set-car!**

```
(set-car! x y)
```

x 必须是一个pair，将x 的 car 替换为 y

```lisp
(define x (list (list a b) c d))
(define y (list e f))
(set-car! x y)
; (list (list e f) c d)
```

<img src="3-3.assets/image-20240221101739673.png" alt="image-20240221101739673" style="zoom:50%;" />

这样可能会有一些“垃圾”生成，可以用垃圾回收解决。

```lisp
(define z (cons y (cdr x)))
```

<img src="3-3.assets/image-20240221101909028.png" alt="image-20240221101909028" style="zoom:67%;" />



**（2）set-cdr!**

```
(set-cdr! x y)
```

x 必须是一个pair，将x 的 cdr 替换为 y

```lisp
(define x (list (list a b) c d))
(define y (list e f))
(set-cdr! x y)
```

<img src="3-3.assets/image-20240221102019422.png" alt="image-20240221102019422" style="zoom: 67%;" />

（3）使用 set-car!，set-cdr!和 get-new-pair 可以实现 cons：

```lisp
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
```

get-new-pair是Lisp实现中必须作为内存管理的一部分来实现的操作之一。





#### Sharing and identity

如果不同的数据对象共享同一个pair时，set!可能会出现问题。

```lisp
(define x (list 'a 'b))
(define z1 (cons x x))
(define z2 (cons (list 'a 'b) (list 'a 'b)))
```

![image-20240222081218342](3-3.assets/image-20240222081218342.png)

![image-20240222081234509](3-3.assets/image-20240222081234509.png)

symbol 是唯一的，但是这个symbol是共享的，z2作为共享的结构很难被察觉到

每个list都会有一个新的指针出现，但是symbol只有一个！



```lisp
(define x (list 'a 'b))
(define z1 (cons x x))
(define z2 (cons (list 'a 'b) (list 'a 'b)))

(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
z1
; ((a b) a b)
(set-to-wow! z1)
;((wow b) wow b)

z2
; ((a b) a b)
(set-to-wow! z2)
;((wow b) a b)
```

"the same list" ，不同的结果



使用`eq?`检验共享

```lisp
(eq? (car z1) (cdr z1))
; true
(eq? (car z2) (cdr z2))
; false
```

利用共享来极大地扩展可以用对表示的数据结构。

除非我们很好地理解数据对象是如何共享的，否可能会产生意想不到的结果。



#### Mutation is just assignment

recall：

pair 可以用过程来进行表示。

```lisp
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation -- CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
```

我们可以使用赋值和局部状态将可变数据对象实现为过程。

可变数据类型也可以表示为过程，太奇妙了！

```lisp
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error "Undefined operation -- CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
(define (set-car! z new-value)
  ((z 'set-car!) new-value)
  z)
(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value)
  z)
```

assignment and mutation are equipotent: Each can be implemented in terms of the other.

assignment 和 mutation 是等价的！

assignment requires us to modify the environment, which is itself a mutable data structure

赋值操作要求我们修改环境，**而环境本身就是一个可变的数据结构**。





### 3.3.2 Representing Queues

set-car! 和 set-cdr! 可以允许我们构建 不能用 car 和 cdr 构建的 数据结构：

（1）Queues

A queue is a sequence in which 

items are inserted at one end (called the rear of the queue) and deleted from the other end (the front). 

A queue is sometimes called a **FIFO** (first in, first out) buffer

Items are always removed in the order in which they are inserted

<img src="3-3.assets/image-20240223095219928.png" alt="image-20240223095219928" style="zoom: 67%;" />

定义的构造器、选择器和修改器

**<1> a constructor:**

```lisp
(make-queue)
```

returns an **empty** queue (a queue containing no items).

构造一个空的队列

**<2> two selectors:**

```lisp
(empty-queue? <queue>)
```

tests if the queue is **empty**.

```lisp
(front-queue <queue>)
```

returns **the object at the front of the queue**, signaling an error if the queue is empty; it does not modify the queue.

队列是否空？

取队首的元素

**<3> two mutators:**

```lisp
(insert-queue! <queue> <item>)
```

**inserts the item at the rear of the queue** and returns the modified queue as its value.

```lisp
(delete-queue! <queue>)
```

removes the item at the front of the queue and returns the modified queue as its value, signaling an error if the queue is empty before the deletion.

将元素插入队列的尾部

弹出队首的元素

我们当然可以将其表示为普通list，但是insert-queue! 的效率会变为 $O(n)$

而如果用queue，就是 $O(1)$ 插入，$O(1)$ 删除

为了能够快速得到list末尾的指针，我们动态维护一个就可以：

将队列表示为一个列表，**加上一个指示列表中最后 一个 pair 的额外指针**

我们可以参考 rear 指针，从而**避免扫描列表**

queue：

front-ptr 和 rear-ptr 的cons

![image-20240223100143990](3-3.assets/image-20240223100143990.png)

```lisp
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue (define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue))) item) (set-cdr! queue item))
```

上面是针对 front-ptr 和 rear-ptr 的 辅助过程

实现实际的队列操作如下：

```lisp
(define (empty-queue? queue) (null? (front-ptr queue)))
```

```lisp
(define (make-queue) (cons '() '()))
```

```lisp
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))
```

```lisp
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue)))) 
```

先根据 item 构建一个新的 pair

然后分类看：

（1）如果原queue为空，那么就将queue的front和rear设置为new-pair

（2）如果原queue非空，那么需要设置queue 的 rear 的cdr 为new-pair，然后将rear-ptr 指向这个 new-pair

最后都是需要返回一个新的queue

<img src="3-3.assets/image-20240223100839972.png" alt="image-20240223100839972" style="zoom:67%;" />



```lisp
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue))) 
```

如果发现queue是空的，还在delete，那么直接error即可

否则就只需要修改 queue 的front-ptr 即可，将front-ptr设置为front的cdr即可

<img src="3-3.assets/image-20240223130106046.png" alt="image-20240223130106046" style="zoom:67%;" />



### 3.3.3 Representing Tables

回顾之前实现过的表结构：

（1）maintaining **a table of records** indexed **by identifying keys**

（2）**two-dimensional tables**, in which information is stored and retrieved using **two keys**

一个是有一个key的记录索引表

一个是有两个key二维表



接下来介绍构造可变的表结构。

```
a:  1
b:  2
c:  3
```

![image-20240224113120090](3-3.assets/image-20240224113120090.png)

一个表由多个表项组成，每个表项就是一个pair，将这些pair串起来，就是一个table。



**（1）查找 lookup**

```lisp
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
```

assoc 就是 根据records的指针和一个给定的key，查找table中的具体一个record。

lookup就是看assoc是否返回了有效的record，如果找到了，将cdr，也就是record的value返回即可。



**（2）插入 insert** 

```lisp
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  'ok)
```

  (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  'ok)先用 assoc 查找一下是否存在 record？

如果找到了record，通过set-cdr!就可以修改 value。

如果没有找到，就需要通过cons构建一个新的pair，然后通过set-cdr!将pair头插到table中。



**（3）构建 make-table**

```lisp
(define (make-table)
  (list '*table*))
```



#### Two-dimensional tables

```
math:
    +:  43
    -:  45
    *:  42
letters:
    a:  97
    b:  98
```

二维的表用多个一维表构造即可

<img src="3-3.assets/image-20240224114131014.png" alt="image-20240224114131014" style="zoom: 67%;" />

仔细看，其实二维表的结构和一维表的结构是一样的，将 pair 的 key 换为 子表的 名字，将 value 换为 子表本身即可。

<img src="3-3.assets/image-20240224114445426.png" alt="image-20240224114445426" style="zoom:67%;" />

通过第一个key查找子表，然后用第二个key查找子表中的record即可

**（1）查找 lookup** 

```lisp
(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
```

稍微改一下  一维表的 lookup 就可以了。



**（2）插入 insert**

```lisp
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
```

先根据key-1 查询对应的子表是否存在？

如果不存在，那么需要通过cons创建一个pair，然后用list创建一个list，最后通过cons和(cdr table)实现子表的头插！

如果key-1 存在，需要看key-2 在key-1 的子表中是否存在？

如果存在，通过assoc找到的record，直接修改 value 即可。

如果不存在，需要cons 和 set-cdr! 将 构建的 key - value pair头插到子表中。



#### Creating local tables

如果用之前的 local variables + dispatch ，message passing 的方式改写 table？

```lisp
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
```

将 insert 和 lookup 进行简单的封装，就可以让表的结构作为局部变量隐含在make-table中。



