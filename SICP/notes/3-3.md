## 3.3 Modeling with Mutable Data

recall chapter2：

数据抽象的原则，数据结构用**构造函数和选择器来指定**，构造函数创建数据对象，**选择器访问复合数据对象的各个部分**。

pair作为合成复合数据的通用“粘合剂”。



现在：

我们需要定义**可变数据类型**。

为了对状态变化的复合对象进行建模，除了选择器和构造器之外，我们还将设计数据抽象，包括称为mutator的操作，这些操作**可以修改数据对象**。

为其定义了mutator的数据对象称为**可变数据对象**。

复杂系统被建模为具有**局部状态的对象集合**。

为最基本的pair定义mutator，

**然后就可以根据这个有mutator性质的变量构造mutable data objects**





### 3.3.1 Mutable List Structure

<img src="3-3.assets/image-20240221101219203.png" alt="image-20240221101219203" style="zoom:50%;" />

```lisp
; x
(list (list a b) c d)
; y
(list e f)
```



下面为pair添加两个新的过程：

**（1）set-car!**

```
(set-car! x y)
```

x 必须是一个pair，将x 的 car 替换为 y

```lisp
(define x (list (list a b) c d))
(define y (list e f))
(set-car! x y)
; (list (list e f) c d)
```

<img src="3-3.assets/image-20240221101739673.png" alt="image-20240221101739673" style="zoom:50%;" />

这样可能会有一些“垃圾”生成，可以用垃圾回收解决。

```lisp
(define z (cons y (cdr x)))
```

<img src="3-3.assets/image-20240221101909028.png" alt="image-20240221101909028" style="zoom:67%;" />



**（2）set-cdr!**

```
(set-cdr! x y)
```

x 必须是一个pair，将x 的 cdr 替换为 y

```lisp
(define x (list (list a b) c d))
(define y (list e f))
(set-cdr! x y)
```

<img src="3-3.assets/image-20240221102019422.png" alt="image-20240221102019422" style="zoom: 67%;" />

（3）使用 set-car!，set-cdr!和 get-new-pair 可以实现 cons：

```lisp
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
```

get-new-pair是Lisp实现中必须作为内存管理的一部分来实现的操作之一。





#### Sharing and identity

如果不同的数据对象共享同一个pair时，set!可能会出现问题。

```lisp
(define x (list 'a 'b))
(define z1 (cons x x))
(define z2 (cons (list 'a 'b) (list 'a 'b)))
```

![image-20240222081218342](3-3.assets/image-20240222081218342.png)

![image-20240222081234509](3-3.assets/image-20240222081234509.png)

symbol 是唯一的，但是这个symbol是共享的，z2作为共享的结构很难被察觉到

每个list都会有一个新的指针出现，但是symbol只有一个！



```lisp
(define x (list 'a 'b))
(define z1 (cons x x))
(define z2 (cons (list 'a 'b) (list 'a 'b)))

(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
z1
; ((a b) a b)
(set-to-wow! z1)
;((wow b) wow b)

z2
; ((a b) a b)
(set-to-wow! z2)
;((wow b) a b)
```

"the same list" ，不同的结果



使用`eq?`检验共享

```lisp
(eq? (car z1) (cdr z1))
; true
(eq? (car z2) (cdr z2))
; false
```

利用共享来极大地扩展可以用对表示的数据结构。

除非我们很好地理解数据对象是如何共享的，否可能会产生意想不到的结果。



















