### Building Abstractions with Procedures

**关键要点**

 \1. Combining several simple ideas into one compound one, and thus all complex ideas are made.

把几个**简单的想法组合成一个复杂的想法**，这样就形成了所有复杂的想法。

\2. The second is bringing two ideas, whether simple or complex, together, and setting them by one another so as to take a view of them at once, without uniting them into one, by which it gets all its ideas of relations. 

第二种方法是把**两个简单的或复杂的概念放在一起，把它们彼此联系起来**，以便立即对它们有一个看法，而不是把它们统一起来，从而得到它的一切关系的概念。

\3. The third is separating them from all other ideas that accompany them in their real existence: this is called abstraction, and thus all its general ideas are made.

第三种方法是把它们与在它们的现实存在中伴随它们的一切其他观念分离开来，这叫做抽象，这样就形成了抽象的一切**一般观念**。



组合、关联、抽象。



（1）过程是抽象的。

（2）计算机就是小精灵，程序员就是施法的巫师

（3）需要可视化程序、调试程序、让程序是模块化的



#### Programming in Lisp

（1）为了描述过程，需要用lisp这个符号描述语言

（2）The language was conceived by John McCarthy and is based on his paper **Recursive Functions of Symbolic Expressions and Their Computation by Machine** (McCarthy 1960).

约翰 麦卡锡就是它的作者。

（3）scheme是Lisp的方言。

（4）Fortran 第一古老，Lisp 第二古老。

（5）效率低、但是可以用在一些不需要追求效率的场合。

Lisp has become a language of choice for **operating-system shell languages** and for extension languages for editors and computer-aided design systems.

（6）Lisp的过程和数据是一个东西，灵活性高。

（7）过程就是数据、数据就是过程，两者在Lisp中的界限十分模糊。

The most significant of these features is the fact that **Lisp descriptions of processes, called procedures, can themselves be represented and manipulated as Lisp data.** 

（8）Lisp并不是主流的编程语言，但是还是有一定的学习价值。



## 1.1 The Elements of Programming

- **primitive expressions** 

  represent the simplest entities the language is concerned with

- **means of combination** 

  compound elements are built from simpler ones

- **means of abstraction**

  by which compound elements can be named and manipulated as units



（1）最基本的原语、组合、抽象。

（2）数据和过程并没有什么特殊的区分，是一个东西。

**（3）primitive 、combination and  abstraction of data and prcedures**

procedures and data

data is "stuff'' that we want to manipulate, and "procedures" are descriptions of the rules for manipulating the data.

any powerful programming language should be able to describe **primitive data and primitive procedures** and should have methods for **combining and abstracting procedures and data**



### 1.1.1 Expressions

**（1）present Lisp with a number**

基本的数字

```lisp
486
```

```
// output
486
```

**（2）compound expression**

组合

```lisp
(+ 137 349)
(- 1000 334)
(* 5 99)
(/ 10 5)
(+ 2.7 10)
```

```
486
666
495
2
12.7
```

formed by delimiting a list of expressions within parentheses in order to denote procedure application, are called ***combinations***. The leftmost element in the list is called the ***operator***, and the other elements are called ***operands***. 

组合：操作数+运算符+括号



前缀表示法的优点：

```lisp
(+ 21 35 12 7)
(* 25 4 12)
```

```
75
1200
```

直观上看，就是只需要写一个运算符，就可以实现连续的 “加” 和 “乘”



**（3）allow combinations to be *nested***

组合嵌套

```lisp
(+ (* 3 5) (- 10 6))
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```

```
19
57
57
```

记得对括号进行缩进，否则十分难看。

**automatically indents to the proper pretty-print position** whenever a new line is started and one that highlights the matching left parenthesis whenever a right parenthesis is typed.

Even with complex expressions, the interpreter always operates in the same basic cycle: **It reads an expression from the terminal, evaluates the expression, and prints the result.**

从terminal中读取字符，然后分析表达式，打印结果。

Lisp programmers know the value of everything but the cost of nothing.

每个表达式都有一个值！但是成本极大，效率低。





### 1.1.2 Naming and the Environment



（1）the name identifies a ***variable*** whose ***value*** is the object

变量和值

```lisp
(define size 2)
size
(* 5 size)
```

```
2
10
```

```lisp
(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
(define circumference (* 2 pi radius))
circumference
```

```
314.159
62.8318
```

Define is our language's simplest means of abstraction, **for it allows us to use simple names to refer to the results of compound operations, such as the circumference computed above**. 

复杂的程序是通过一步一步地构建越来越复杂的计算对象来构建的。

 name-object associations can be created incrementally in successive interactions.

It should be clear that the possibility of **associating values with symbols and later retrieving them means that the interpreter must maintain some sort of memory that keeps track of the name-object pairs**. 

将值与符号关联并稍后检索它们的可能性意味着解释器必须维护某种类型的内存来跟踪**名称-对象对**

变量和变量的值的这个pair需要进行记录，那就构造一个表！



### 1.1.3 Evaluating Combinations

**（1）如何计算一个表达式的值？**

1.  计算组合的子表达式。

2.  将作为最左边子表达式(操作符)值的过程应用于作为其他子表达式(操作数)值的参数。



这个过程本身是递归的！

```lisp
(* (+ 2 (* 4 6))
   (+ 3 5 7))
```

```
390
```

使用树型结构进行表达式分析是十分方便的。

![image-20240111120245022](/home/boneinscri/.config/Typora/typora-user-images/image-20240111120245022.png)

Each combination is represented by a **node** with **branches** corresponding to the **operator** and the **operands** of the combination stemming from it.

In general, we shall see that recursion is a very powerful technique for dealing with **hierarchical, treelike objects**.

**percolate values upward** , 向上渗透值

 an example of a general kind of process known as **tree accumulation.**

树积累



（2） We take care of the **primitive cases**

考虑最基本的情况

- the values of numerals are the **numbers** that they **name**,
- the values of **built-in** operators are the machine instruction sequences that carry out the corresponding operations, and
- the values of other names are the **objects** associated with those **names** in the environment.

数字、built-in 的运算符、通过define定义的object



**加法、减法、乘法这样的运算符的值其实是机器指令本身。**

(define x 3) is not a combination

定义不是一个组合。

The various kinds of expressions (each with its associated **evaluation rule**) constitute the syntax of the programming language.

每个表达式的 evalution rule 就组成了这个编程语言的语法。

the evaluation rule for expressions can be described by **a simple general rule together with specialized rules for a small number of special forms**

表达式的求值规则可以用一个简单的一般规则和少数特殊形式的专门规则来描述



**（3）Lisp不太关心语法，其他语言的一些语法更多是一种语法糖**

In comparison with users of other languages, **Lisp programmers, as a rule, are less concerned with matters of syntax**.

Syntactic sugar causes cancer of the semicolon.

语法糖导致了分号的癌症



###  1.1.4 Compound Procedures

- Numbers and arithmetic operations are primitive data and procedures.

基本的数据？就是数字

基本的过程？就是算术运算

- Nesting of combinations provides a means of combining operations.

如何实现组合？嵌套的combinations

- Definitions that associate names with values provide a limited means of abstraction.

如何实现抽象？可以用define将 name 和 value 进行绑定



**（1）过程定义？**

*procedure definitions*

这是一种更强大的抽象技术，**通过它可以为复合操作指定一个名称，然后将其称为一个单元**

```lisp
(define (square x) (* x x))
(square 21)
(square (+ 2 5))
(square (square 3))
```

```
441
49
81
```

To square something, multiply it by itself.

We have here a **compound procedure**, which has been given the name square. 

这里的 x 就是“代词”，given a local name, `x`

x 是局部的名称。

```
(define (<name> <formal parameters>) <body>)
```

名字：name

参数：parameters

具体内容：body

<body>是一个表达式，当**将形式形参替换为应用过程的实际实参**时，该表达式将生成应用过程的值。



更多的例子

```lisp
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
```

```
25
```



过程可以复合，也就是一种复用。

```lisp
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
(f 5)
```

```
136
```



### 1.1.5 The Substitution Model for Procedure Application

过程应用的替代模型

解释器对组合的元素求值，并将过程(即组合的操作符的值)应用于参数(即组合的操作数的值)



这个替代，将参数应用于过程的函数内嵌在解释器。

To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.

若要将复合过程**应用于实参**，请对过程体进行求值，其中**每个形式形参都由相应的实参替换**。

使用实参代替所有的形参，就是这个过程的求值过程。



**（1）举例分析 (f 5) 是怎么进行分析的**

```lisp
(define (square x) (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
```

```
(f 5)
->
(sum-of-squares (+ a 1) (* a 2)) -> (sum-of-squares (+ 5 1) (* 5 2))
// Evaluating this combination involves three subproblems
-> 
(+ (square 6) (square 10))
-> 
(+ (* 6 6) (* 10 10))
-> 
(+ 36 100)
// finally
->
136
```

实际上，“替换”是通过使用形式参数的局部环境来完成的，上面的过程只是一个方便理解的简化过程。

这个部分属于解释器的那块。

最后一章，会给出一个编译器和解释器的完整实现！

The substitution model is no exception. In particular, when we address in chapter 3 the use of procedures with "mutable data'', **we will see that the substitution model breaks down and must be replaced by a more complicated model of procedure application**

there is a long history of erroneous definitions of **substitution** in the literature of logic and programming semantics

给替代的这个过程进行严格的数学证明是很困难的。



#### Applicative order versus normal order

下面介绍第二种求值方法。

（1）解释器首先求操作符和操作数，然后将结果过程应用于结果参数，这是第一种方法。

（2）在需要操作数时才对其求值，它将首先用操作数表达式替换形参，直到得到只涉及基本操作符的表达式，然后执行求值。

```
(f 5)
->
(sum-of-squares (+ 5 1) (* 5 2))
-> 
(+ (square (+ 5 1)) (square (* 5 2)))
->
(+  (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
->
(+  (* 6 6) (* 10 10))
->
(+ 36 100)
->
136
```

相同的结果，但是求解过程不同。



总结，求值顺序有两种：

（1）应用顺序求值

fully expand and then reduce

（2）正常顺序求值

evaluate the arguments and then apply



一般情况下，两个的求值结果是一样的，但是有反例（exercise 1.5）





**Lisp 使用什么求值顺序呢？**

Lisp uses **applicative-order** evaluation, partly because of the additional efficiency obtained from avoiding multiple evaluations of expressions such as those illustrated with (+ 5 1) and (* 5 2) above and, more significantly, because normal-order evaluation becomes much more complicated to deal with when we leave the realm of procedures that can be modeled by substitution. 

避免多次求值，从而增加效率。

正常顺序的求值变得更加复杂。

但是，normal-order evaluation can be an extremely valuable tool。正常顺序求值还是有一定的好处的。



