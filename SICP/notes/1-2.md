## 1.2 Procedures and the Processes They Generate

我们已经使用了基本的算术运算，

我们已经组合了这些运算，

我们已经通过将这些运算定义为复合过程来抽象这些复合运算。



**基本运算、组合运算、复合运算。**

可视化所考虑的行为的结果的能力对于成为一名专业程序员是至关重要的。



什么是 过程？

A procedure is a pattern **for the local evolution of a computational process**.



### 1.2.1 Linear Recursion and Iteration

**线性递归和线性迭代**

![image-20240122143249867](1-2.assets/image-20240122143249867.png)

**呈现先膨胀后收缩的形状**

**有很明显的延迟计算的趋势**

**有一些额外的“隐藏”信息，由解释器维护，不包含在程序变量中，它指示进程在协商延迟操作链中的“位置”**

**链越长，必须保存的信息就越多**



A linear recursive process for computing 6!

上面就是一个线性递归计算 6 的阶乘的过程。

递归函数的定义

![image-20240122143333952](1-2.assets/image-20240122143333952.png)

如果稍微变型一下：

![image-20240122143355136](1-2.assets/image-20240122143355136.png)

于是我们可以写一个递归函数：

```lisp
(define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
```

还有一个办法，就是迭代，如下：

![image-20240122143508829](1-2.assets/image-20240122143508829.png)

下面是迭代的过程可视化：

![image-20240122143522305](1-2.assets/image-20240122143522305.png)

 A linear iterative process for computing 6!

**不会增长和收缩**

**迭代过程的状态可以通过固定数量的状态变量来总结，同时还有一个固定的规则来描述状态变量在过程从一个状态移动到另一个状态时应该如何更新，以及一个(可选的)结束测试来指定过程应该在哪些条件下终止。**

1. 有固定数量的状态变量
2. 有更新状态变量的规则
3. 可选的终止条件



迭代过程不需要辅助寄存器，只需要固定的寄存器就可以完成！

实现递归过程需要使用称为堆栈的辅助数据结构。





上面就是一个线性迭代计算 6 的阶乘的过程。

代码如下：

```lisp
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
```

如果将 n 隐藏，将 fact-iter 放到 factorial 中，就有：

```lisp
(define (factorial n)
    (define (iter product counter)
        (if (> counter n)
            product
            (iter (* counter product)
                  (+ counter 1))))
    (iter 1 1))
```



递归和迭代似乎没有什么不同，

这两种方法甚至执行相同的乘法序列，得到相同的部分积序列。

**当我们考虑这两个过程的“可视化形状”时，我们发现它们的演变完全不同。**



疑惑？fact-iter 不也是自己调用自己吗？也是递归。

即fact-iter本身是**递归**的，但是不是**线性递归**，我们将诸如fact-iter之类的递归过程称为**生成迭代过程**

It may seem disturbing that we refer to a recursive procedure such as fact-iter **as generating an iterative process.**

它的状态完全由它的三个状态变量捕获，并且解释器只需要跟踪三个变量就可以执行该过程

**只需要跟踪 product counter max-count 这三个变量就可以完成 fact-iter的过程，所以并不需要维护额外的信息，即不是线性递归。**



大多数语言(包括Ada、Pascal和C)的实现都是任何递归过程的解释都会消耗一定数量的内存，并且随着过程调用的数量而增长，**即使所描述的过程原则上是迭代的。**

因此，这些语言只能通过使用特殊用途的“循环结构”来描述迭代过程**，例如do、repeat、until、for和while。**



Scheme 并不同，它将在常数空间中执行迭代过程，**即使迭代过程是由递归过程描述的。**

即Scheme**没有循环结构也可以实现迭代过程**，即使在描述上是用递归过程描述迭代过程。



An implementation with this property is called **tail-recursive**.

即尾递归

