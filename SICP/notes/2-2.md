## 2.2 Hierarchical Data and the Closure Property



pair 可以用来构造复杂的数据。

可视化表示pair

```lisp
(cons 1 2)
```

![image-20240126113515548](2-2.assets/image-20240126113515548.png)

**Box-and-pointer representation** of `(cons 1 2)`.

如果要将 1 2 3 4 绑在一起，要怎么做？

有两种方法。

![image-20240126113603889](2-2.assets/image-20240126113603889.png)

cons 可以嵌套，即拥有闭包的特性。

an operation for combining data objects **satisfies the closure property** if the results of combining things with that operation can themselves **be combined using the same operation**

所以，cons可以创建层次结构。

在抽象代数中，如果对集合中的元素**应用该操作产生的元素再次成为集合中的元素**，则该元素集合在操作下被称为闭包。



即组合的元素本身可以是组合，这就是一种抽象代数里面的闭包。

在Fortran或Basic中，通常通过将数据元素组装成数组来组合数据元素，**但是不能形成元素本身就是数组的数组**

这要求程序员显式地操作指针，并遵守结构的每个字段**只能包含预先指定形式的元素的限制**

This limitation lies behind Alan Perlis's comment in his foreword to this book: 

"In Pascal the plethora of declarable data structures induces a specialization within functions that inhibits and penalizes casual cooperation.  

It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.''

用100个函数操作一个数据结构比用10个函数操作10个数据结构要好

### 2.2.1 Representing Sequences

![image-20240126114135955](2-2.assets/image-20240126114135955.png)

数据对象的有序集合，即创建一个sequence。

an ordered collection of data objects

每一个pair的car是sequence中对应的 item，而 cdr是sequence中的**下一个pair**。

最后一个pair的cdr通过指向一个不同的值来表示序列的结束，该值**不是pair**，在框和指针图中表示为**对角线**，在程序中表示为变量**nil**的值。

```lisp
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
```

这也被称为list

```lisp
; (list <a1> <a2> ... <an>)
; ->
; (cons <a1> (cons <a2> (cons ... (cons <an> nil) ...)))

(define one-through-four (list 1 2 3 4))
one-through-four
(1 2 3 4)
```

```lisp
(car one-through-four)
; 1
(cdr one-through-four)
; (2 3 4)
(cons 10 one-through-four)
; (10 1 2 3 4)
(cons 5 one-through-four)
; (5 1 2 3 4)
```

The word nil is a contraction of the Latin word nihil, which means "nothing.''

nil的值用于终止对链，可以认为是一个没有元素的序列，即空列表。

nil是一个普通的名称，将其用作值为列表结束标记的变量

(就像true是具有真值的普通变量一样)



#### List operations

过程list-ref接受一个列表和一个数字n作为参数，并返回列表的第n项。

习惯上**以0开头**对列表中的元素进行编号。

For n = 0, list-ref should return the car of the list.

Otherwise, **`list-ref` should return the (*n* - 1)st item of the `cdr` of the list**.

```lisp
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))
; 0 -> 1
; 1 -> 4 
; 2 -> 9
; 3 -> 16
; 4 -> 25
(list-ref squares 3)
; 16
```

得大 list 的长度？

```lisp
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))

(length odds)
; 4
; length 这个过程就是一个递归
```

Scheme includes a primitive predicate `null?`, 

**which tests whether its argument is the empty list**



如果使用迭代的方式描述 length？

```lisp
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
```

还需要实现一个 添加append的过程？

即将一个list拼接在另一个list的后面。

```lisp
(append squares odds)
; (1 4 9 16 25 1 3 5 7)

(append odds squares)
; (1 3 5 7 1 4 9 16 25)
```

递归过程描述入下：

```lisp
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
```



记住，list 是scheme自带的！



#### Mapping over lists

One extremely useful operation is to **apply some transformation to each element in a list and generate the list of results.**  



对list的每个元素进行缩放

```lisp
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
(scale-list (list 1 2 3 4 5) 10)
(10 20 30 40 50)
```

可以使用高阶过程对map的思想进行进一步抽象。

这里的高阶过程称为map。

```lisp
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
; (10 2.5 11.6 17)
(map (lambda (x) (* x x))
     (list 1 2 3 4))
; (1 4 9 16)
```

使用map实现scale-list

```lisp
define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
```

scheme 的标准提供了一个**更加强大，更加通用的map**：

```lisp
(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
; (741 852 963)

(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
; (9 12 15)
```

This more general map takes **a procedure of *n* arguments**, **together with *n* lists**, and applies the procedure to all the **first** elements of the lists, all the **second** elements of the lists, **and so on**, **returning a list of the results**

（1）一个n个参数的过程

（2）n个list

map有助于建立一个抽象屏障，**将转换列表的过程的实现**与**如何提取和组合列表元素的细节**隔离开来

**我们只需要关心list中的每个元素如何改变，不关心如何获取每个元素。**



### 2.2.2 Hierarchical Structures

构造 ((1 2) 3 4)

```lisp
(cons (list 1 2) (list 3 4))
```

<img src="2-2.assets/image-20240126141728751.png" alt="image-20240126141728751" style="zoom: 67%;" />

树型结构的表示：

![image-20240126141812124](2-2.assets/image-20240126141812124.png)

递归是处理树形结构的天然工具，因为我们经常可以将树上的操作简化为对其分支的操作，这些分支又简化为对分支的分支的操作，以此类推，直到我们到达树的叶子。

Recursion is a **natural tool for dealing with tree structures**, since we can often reduce operations on trees to operations on their branches, which reduce in turn to operations on the branches of the branches, and so on, **until we reach the leaves of the tree.**

```lisp
(define x (cons (list 1 2) (list 3 4)))

(length x)
; 3
(count-leaves x)
; 4

(list x x)
(((1 2) 3 4) ((1 2) 3 4))

(length (list x x))
; 2
(count-leaves (list x x))
; 8
```

上面代码比较了length 和 count-leaves 的不同

计算 length 的方法：

```
(1) Length of a list x is 1 plus length of the cdr of x.
(2) Length of the empty list is 0.
```

计算 count-leaves 的方法：

```
(1) Count-leaves of a tree x is count-leaves of the car of x plus count-leaves of the cdr of x. 
(2) Count-leaves of the empty list is 0.
(3) Count-leaves of a leaf is 1.
```

Scheme provides the primitive predicate `pair?`, **which tests whether its argument is a pair.** 

```lisp
(define (count-leaves x)
  (cond ((null? x) 0)  
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
```

**(x nil) 的pair? 就返回 0，即只要cdr 返回的是nil，那么pair? 就返回 $f**



#### Mapping over trees

之前已经介绍过了如何对一个list进行map，下面就是如何对一个用list实现的tree进行map

首先是给出 对树的每个叶子结点进行scale的过程。

```lisp
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
            10)
; (10 (20 (30 40) 50) (60 70))
```

- 我们映射序列，依次缩放每个子树，并返回结果列表。
- 在基本情况下，树是一片叶子，我们只需乘以这个因子。

第二种写法：

```lisp
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
```

Many tree operations can be implemented 

**by similar combinations of sequence operations and recursion.**

**树的许多问题可以用 序列操作和递归实现。**



### 2.2.3 Sequences as Conventional Interfaces

数据抽象允许我们设计程序而不陷入数据表示的细节。

下面介绍 **the use of conventional interfaces**

首先是   the sum of the squares of the **leaves that are odd**

```lisp
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)  
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
```

树型结构的叶结点求和，只不只对奇数的那些叶子结点求和



然后是  a list of all the **even** Fibonacci numbers Fib(k), 

where k is less than or equal to a given integer n

Fib 数列，只保留 偶数

```lisp
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
```



这两个程序是有共同之处的。

（1）

**enumerates** the leaves of a tree; 枚举

**filters them, selecting the odd ones;** 过滤

squares each of the selected ones;  运算

**accumulates** the results using +, starting with 0. 累积

![image-20240126200022280](2-2.assets/image-20240126200022280.png)

（2）
**enumerates** the integers from 0 to *n*; 枚举

**computes** the Fibonacci number for each integer; 运算

**filters** them, selecting the even ones; and 过滤

**accumulates** the results using `cons`, starting with the empty list. 累积

![image-20240126200031400](2-2.assets/image-20240126200031400.png)

Our two procedures decompose the computations in a different way, spreading the **enumeration** over the program and mingling it with the **map**, the **filter**, and the **accumulation**.  



#### Sequence Operations

**（1）map，已经介绍过了** 

```lisp
(map square (list 1 2 3 4 5))
; (1 4 9 16 25)
```



**（2）filter**

```lisp
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
(filter odd? (list 1 2 3 4 5))
(; 1 3 5)
```



**（3）accumulation**

积累

```lisp
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(accumulate + 0 (list 1 2 3 4 5))
; 15
(accumulate * 1 (list 1 2 3 4 5))
; 120
(accumulate cons nil (list 1 2 3 4 5))
; (1 2 3 4 5)
```



**（4）enumerate**

generate the sequence of integers in a given range

```lisp
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
; (enumerate-interval 2 7)
; (2 3 4 5 6 7)
```



枚举一颗树的所有叶结点：

```lisp
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
; (1 2 3 4 5)
```



**重写 sum-odd-squaresfringe**

所有奇数的平方和

```lisp
(define (sum-odd-squares tree)
  (accumulate +
              0
              (map square
                   (filter odd?
                           (enumerate-tree tree)))))
```



**重写 even-fibs**

偶数fib数

```lisp
(define (even-fibs n)
  (accumulate cons
              nil
              (filter even?
                      (map fib
                           (enumerate-interval 0 n)))))
```

**优雅，太优雅了**

this helps us make program designs that are modular

**这有助于我们进行模块化的程序设计**

Modular construction is a powerful strategy for controlling **complexity in engineering design.**  

信号处理应用中，设计人员通常通过从标准化**的滤波器**和**换能器**系列中选择级联元件来构建系统

filters and transducers



**构建 Fib 数列的平方序列**

```lisp
(define (list-fib-squares n)
  (accumulate cons
              nil
              (map square
                   (map fib
                        (enumerate-interval 0 n)))))
(list-fib-squares 10)
; (0 1 1 4 9 25 64 169 441 1156 3025)
```

**奇数平方的乘积**

```lisp
(define (product-of-squares-of-odd-elements sequence)
  (accumulate *
              1
              (map square
                   (filter odd? sequence))))

(product-of-squares-of-odd-elements (list 1 2 3 4 5))
; 225
```

**不断重复使用某些过程，实现了高效的模块化**



**如果我们想得到 薪水最高的程序员的薪水，可以这么写：**

```lisp
(define (salary-of-highest-paid-programmer records)
  (accumulate max
              0
              (map salary
                   (filter programmer? records))))
```

太强大了！



Richard Waters (1979) developed a program that automatically analyzes **traditional Fortran programs**, 

viewing them in terms of **maps, filters, and accumulations.**  

He found that **fully 90 percent of the code** in the Fortran Scientific Subroutine Package fits neatly into this paradigm



Lisp作为一种编程语言取得成功的原因之一是，

列表提供了一种表达有序集合的**标准媒介**，

以便**可以使用高阶操作对它们进行操作**



**目前我们用到的都是有限序列，在3.5 会进一步介绍无限序列。**

