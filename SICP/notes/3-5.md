## 3.5 Streams

In this section, we explore an alternative approach to modeling state, 

**based on data structures called *streams*.**



使用 streams 来缓解modeling state 的复杂性。



（1）引入stream，其实就是一个 list

（2）每个变量都是 t 的函数，即 x(t)

（3）引入延迟求值的技术

the technique of delayed evaluation





###  3.5.1 Streams Are Delayed Lists



回忆：

list 的通用接口，map、filter、accumulate等

简洁又优雅的方法。

但是效率低。

our programs must construct and **copy data structures (which may be huge) at every step of a process**



计算区间内所有素数和：

（1）程序1，迭代风格

```lisp
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count) (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
```

（2）程序2，使用accumulate

```lisp
(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? (enumerate-interval a b))))
(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
```

We **construct** a list of almost a million integers, **filter** this list by testing each element for primality, and then **ignore** almost all of the result.





为什么使用 stream？

We can formulate programs elegantly **as sequence manipulations**, while attaining the efficiency of incremental computation.

we design our **stream implementation** to automatically and transparently **interleave** the construction of the stream with its use.



stream 的构造器和选择器？

```lisp
(stream-car (cons-stream x y)) = x
(stream-cdr (cons-stream x y)) = y
```



empty-stream和stream-null?

There is a distinguishable object, **the-empty-stream**, which cannot be the result of any cons-stream operation, and which **can be identified with the predicate stream-null?**



**（1）stream-ref**

```lisp
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
```

类似于根据 n 取出 stream 的第 n 个



**（2）stream-map**

```lisp
(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))
```

和 list 的map一样，就是通过递归遍历整个 stream，对stream 的每个 car 进行 proc 的运算后得到一个新的 stream。



**（3）stream-for-each** 

```lisp
(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
```

这个和map十分类似，但是并没有用 cons-stream，

仅仅是遍历整个 stream，然后对stream的每个car 调用 proc。

`Stream-for-each` is useful for viewing streams:

```lisp
(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))
```



To make the stream implementation **automatically and transparently interleave** the construction of a stream with its use, we will arrange for the **cdr of a stream** to be evaluated **when it is accessed by the stream-cdr** procedure rather than when the stream is constructed by cons-stream.

（1）不在cons-stream进行cdr的evaluate

（2）而是在 stream-cdr时进行cdr的evaluate

With **ordinary lists**, both the car and the cdr are evaluated **at construction time**.

With **streams**, the cdr is evaluated **at selection time**.



为了实现 stream，我们需要 delay 和 force这两个过程：

**（1）delay：**

Evaluating (delay &lt;exp&gt;) does not evaluate the expression &lt;exp&gt;, but rather returns **a so-called delayed object**, which we can think of **as a "promise'' to evaluate &lt;exp&gt; at some future time.**

在未来的某个时刻promise，保证evaluate <exp>！



**（2）force：**

takes a delayed object as argument and performs the evaluation -- 

**in effect, forcing the delay to fulfill its promise.**

强制 dealy 履行其承诺



```lisp
(cons-stream <a> <b>)
(cons <a> (delay <b>))
```

两者等价



rather than placing the value of the rest of the stream into the cdr of the pair **we will put there a promise to compute the rest if it is ever requested.**



```lisp
(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))
```



**cons-stream must be a special form.**

**delay** must be a special form, though **force** can be an **ordinary procedure.**



- cons-stream 和 delay 必须是特殊的过程
- 但是 force 可以是一个普通的过程。



#### The stream implementation in action

使用stream重新描述 计算某个区间的素数和？

```lisp
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))

(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))))
; 得到第二个素数就停下来！
```



**（1）解释一下 stream-enumerate-interval？**

```lisp
(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
->
(stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))
```

其cdr是一个承诺，如果有request，将继续执行 (stream-enumerate-interval)。





**（2）解释一下 stream-filter？**

用 stream-car 看一下car对应的数，发现是 10000，不是素数，于是强制执行 stream-enumerate-interval

就这样，一直强制执行 stream-enumerate-interval，

直到发现 10007 不是素数，

 于是 stream-filter 返回

```lisp
(cons 10007
      (delay
        (stream-filter
         prime?
         (cons 10008
               (delay
                 (stream-enumerate-interval 10009
                                            1000000))))))
```



we can think of delayed evaluation as **"demand-driven'' programming**, whereby each stage in the stream process **is activated only enough to satisfy the next stage.**



计算是增量进行的，并没有一次性计算完，**只是表现得像一次性全部计算完了**。。。



也就是一种 "lazy evaluation"，能不计算，就不计算。



####  Implementing `delay` and `force`

**（1） delay**

```lisp
(delay <exp>)
->
(lambda () <exp>)
```

delay must package an expression 

本质就是用 lambda 表达式将 exp 进行 "保存"。





**（2）force**

```lisp
(define (force delayed-object)
  (delayed-object))
```

本质就是 直接调用 delay 的lambda 表达式，将保存的 exp  "释放" 出来。



In many applications, we end up **forcing the same delayed object many times.**

This can lead to serious **inefficiency** in recursive programs involving streams.

为了提高效率，需要优化 force ，使用记忆化！！！

第一次运行时，它保存计算结果，在随后的求值中，它只返回结果。



```lisp
(define (memo-proc proc)
  (let ((already-run? false) 
        (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
(memo-proc (lambda () <exp>))
```

The memoizing optimization is also known as **call-by-need.**

按需调用。



```lisp
(define (delay exp)
    (define (memo-proc proc)
        (let ((already-run? false) 
              (result false))
             (lambda ()
                     (if (not already-run?)
                         (begin (set! result (proc))
                                (set! already-run? true)
                                result)
                         result))))
    (memo-proc (lambda () exp))
    )
(define (force delayed-object)
  (delayed-object))
```

改进后的delay：

- already-run? 表示这个proc是否被执行过？
- result表示记录的结果，如果proc被执行过，直接返回第一次运行时保存的result即可。







