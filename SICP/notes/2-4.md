## 2.4 Multiple Representations for Abstract Data



回忆：

数据抽象，结构化的系统方法。

具体的运算和数据的表示没有关系。

层和层之间没有关联。



By isolating the underlying representations of data objects, we can **divide the task of designing a large program into smaller tasks that can be performed separately**.

But this kind of data abstraction **is not yet powerful enough**, because **it may not always make sense to speak of "the underlying representation'' for a data object.**

一个数据对象可能有不止一种有用的表示，我们**可能希望设计能够处理多种表示的系统**



复数表示

（1）real and imaginary parts

（2）magnitude and angle

复数可以用两种方式表示，**而操纵复数的过程可以用任何一种方式表示**

下面是抽象形成的屏障

![image-20240203172211995](2-4.assets/image-20240203172211995.png)

isolate "higher-level" operations from "lower-level'' representations.  



学习如何处理可能由程序的**不同部分以不同方式表示的数据**

这需要构造泛型过程，**可以对可能以多种方式表示的数据进行操作的过程。**

**data-directed programming**



即我们需要实现**一种可以操作不同表示数据的过程。**



### 2.4.1 Representations for Complex Numbers

复数的表示？

**直角坐标还是极坐标。**

直角形式在大多数情况下优于极坐标形式，否则存在误差。

复数的集合可以被认为是一个具有两个正交轴的二维空间，**实轴和虚轴。**

数z = x + iy(其中$i^2 = - 1$)可以被认为是平面上实坐标为x，虚坐标为y的点。
$$
\begin{array}{l}{\text{Real-part}(z_{1}+z_{2})=\text{Real-part}(z_{1})+\text{Real-part}(z_{2})}\\\\{\text{Inaginary-part}(z_{1}+z_{2})=\text{Inaginary-part}(z_{1})+\text{Inaginary-part}(z_{2})}\\\end{array}
$$
加法和减法就是对应部分的加法和减法，也就是向量的加法和减法。



如果是乘法，就用极坐标比较好。

用极坐标的形式来表示复数，如**幅度和角度**。

两个复数的乘积是**将一个复数拉伸另一个的长度**，然后通过**另一个的角度旋转得到的向量**。
$$
\begin{array}{l}\text{Magnitude}(z_1\cdot z_2)=\text{Magnitude}(z_1)\cdot\text{Magnitude}(z_2)\\\\\text{Angle}(z_1\cdot z_2)=\text{Angle}(z_1)+\text{Angle}(z_2)\end{array}
$$
![image-20240203175010227](2-4.assets/image-20240203175010227.png)


$$
z=x+iy=re^{iA}
$$
选择器如下：

```
real-part
imag-part
magnitude
angle
```

构造器如下：

```
(make-from-real-imag (real-part z) (imag-part z))
(make-from-mag-ang (magnitude z) (angle z))
```

复数的加法、减法、乘法和除法如下：

```lisp
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
```

如何进行转化？
$$
\begin{array}{ll}{\mathrm{x}=r\cos A}&{r=\sqrt{\mathrm{x}^{2}+y^{2}}}\\\\{y=r\sin A}&{A=\arctan(y,\mathrm{x})}\\\end{array}
$$
arctan 可以用Scheme 的 atan 过程计算。

接收 y 和 x 两个参数，返回 正切为 y/x 的角度。参数的符号决定了这个角的象限。

**如果以直角坐标为基础，写出极坐标的选择器和构造器，如下：**

```lisp
(define (real-part z) (car z))
(define (imag-part z) (cdr z))
(define (magnitude z)
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))
(define (angle z)
  (atan (imag-part z) (real-part z)))
(define (make-from-real-imag x y) (cons x y))
(define (make-from-mag-ang r a) 
  (cons (* r (cos a)) (* r (sin a))))
```

**如果以极坐标为基础，写出直角坐标的选择器和构造器，如下：**

```lisp
(define (real-part z)
  (* (magnitude z) (cos (angle z))))
(define (imag-part z)
  (* (magnitude z) (sin (angle z))))
(define (magnitude z) (car z))
(define (angle z) (cdr z))
(define (make-from-real-imag x y) 
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
(define (make-from-mag-ang r a) (cons r a))
```



