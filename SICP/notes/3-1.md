# Chapter 3 Modularity, Objects, and State

模块化、对象和状态



（1）将primitive procedures 和 primitive data 组合，可以构建复合的对象。

（2）抽象是处理大型系统的有效手段。



第三章：

we need strategies to help us structure large systems **so that they will be modular**

更加模块化的手段。

对于系统中的每个对象，**我们构造一个相应的计算对象。**

添加新功能，局部有效即可。





两个组织代码的策略：

（1）The first organizational strategy concentrates on objects, **viewing a large system as a collection of distinct objects whose behaviors may change over time.**

（2）An alternative organizational strategy concentrates **on the streams of information that flow in the system**, much as an electrical engineer views a signal-processing system.



- 对象 ：object-based approach
- 信息流：stream-processing approach



计算模型的转变：

substitution model of computation 

->

**environment model of computation.**



使用延迟求值技术让流方法得到最充分的利用：

decouple simulated time in our model from the order of the events **that take place in the computer during evaluation**



## 3.1 Assignment and Local State

（1）对象有状态

each of which has a state that changes over time.

（2）状态随时间改变

（3）状态受历史状态影响

"Can I withdraw $100? "  depends upon **the history of deposit and withdrawal transactions**

（4）使用足够多的状态变量来描述对象的状态

characterize an object's state by one or more state variables



举例：

我们可以通过**当前余额来描述一个账户的状态**，而不是记住整个账户交易的历史

**a current balance** rather than by remembering the entire history of account transactions.



（5）对象是相互联系、相互影响的。

一个对象的状态变量与其他对象的状态变量可以耦合。



新的计算模型：

（1）分解为**多个计算对象**

（2）每个计算对象必须有自己的**局部状态变量** 描述实际对象的状态

（3）对象的状态**随时间而变化**，相应计算对象的状态变量也必须改变

（4）提供赋值操作符，使我们能够**更改与变量关联的值**。



### 3.1.1 Local State Variables

对**从银行账户取款**的情况进行建模

model the situation of **withdrawing money from a bank account.**



（1）withdraw

takes as argument an amount to be withdrawn.

If there is enough money in the account to accommodate the withdrawal, **then withdraw should return the balance remaining after the withdrawal.**

Otherwise, withdraw should return the **message Insufficient funds.**

假设原始有 100 $

```lisp
(define balance 100)

(define (withdraw amount)
  (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))

(withdraw 25)
; 75
(withdraw 25)
; 50
(withdraw 60)
; "Insufficient funds"
(withdraw 15)
; 35
```



一个奇怪的地方：

withdraw 是一个过程，两次传入的**参数相同，但是结果不同**。

computing mathematical functions **就是参数相同，那么结果就相同**。



until we introduce assignment, **we have no way to create such procedures ourselves.



set! 语句：

```lisp
(set! <name> <new-value>)
```

`Set!` changes <*name*> **so that its value is the result obtained by evaluating <*new-value*>**

改变变量的值



begin语句：

first decrementing balance and **then returning the value of balance.**

```lisp
(begin <exp1> <exp2> ... <expk>)
```

causes the expressions $<exp_1>$ through $<exp_k>$ to be evaluated in sequence and the value of the final expression $<exp_k>$ to **be returned as the value of the entire `begin` form.**



顺序计算、返回最后一个表达式的值



改进：

balance is a name defined **in the global environment** and is freely accessible to be examined or modified by any procedure.

balance is **a local state variable** used by withdraw to keep track of the state of the account.

将全局变量改为局部变量。



```lisp
(define new-withdraw
  (let ((balance 100))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
```

它的行为与withdraw完全相同，**但是它的变量balance不能被任何其他过程访问**

封装反映了被称为隐藏原则的**一般系统设计原则。**

Encapsulation reflects **the general system-design principle** known as the hiding principle



set + 局部变量是一种通用编程技术。

无法使用求值的替代模型来对上面的程序进行分析。

需要新的方法来对构建的程序进行解释。



下面是 make-withdraw 的 过程描述：

```lisp
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))
(W1 50)
; 50
(W2 70)
; 30
(W2 40)
; "Insufficient funds"
(W1 40)
; 10
```

 `W1` and `W2` are completely independent objects, each with its own local state variable `balance`. 

**Withdrawals from one do not affect the other.**

构建独立的对象！



make-account ：

```lisp
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request -- MAKE-ACCOUNT"
                       m))))
  dispatch)

(define acc (make-account 100))
((acc 'withdraw) 50)
; 50
((acc 'withdraw) 60)
; "Insufficient funds"
((acc 'deposit) 40)
; 90
((acc 'withdraw) 60)
; 30


(define acc2 (make-account 100))
; produce a completely separate account object, which maintains its own local balance.
```

account，传入 withdraw，就执行 withdraw 这个过程。传入 deposit ，就执行 deposit 这个过程。取款和存款。



（1）make-account，会创建一个有局部变量 balance 的环境

（2）dispatch 就是 message passing 的编码风格





### 3.1.2 The Benefits of Introducing Assignment

将系统视为具有局部状态的对象集合**是维护模块化设计的一种强大技术**。

考虑一个过程' rand '的设计，**无论何时调用它，它都会返回一个随机选择的整数。**

我们大概想要的是连续调用rand来产生**一个具有均匀分布统计特性的数字序列。**

```
x2 = (rand-update x1)
x3 = (rand-update x2)
```

then the sequence of values *x*1, *x*2, *x*3, `...`, will have the desired statistical properties

x is updated to ax + b modulo m, **where a, b, and m are appropriately chosen integers.**

Given the **same** input twice, it produces the **same** output.



通过上面的 ( ax + b ) % m 的方式产生的随即数是**伪随机，并不是真随机**。

随机数序列的每个数字**与前一个数字无关才是真随机**。

伪随机序列是由精心确定的计算产生的，但具有适当的统计性质。



实现 rand：

**（1）random-init**

We can implement `rand` as a procedure with a local state variable `x` that is initialized to some fixed value `random-init`

**（2）rand-update**

Each call to `rand` computes `rand-update` of the current value of `x`, returns this as the random number, and also stores this as the new value of `x`.

```lisp
(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
```

```lisp
(define random-init 0) 
(define (rand-update x) 
  (let ((a 16807) (b 0) (m 2147483647))
    (modulo (+ (* a x) b) m)
    ))
```

```lisp
(define random-init 1) 
(define (rand-update x) 
    (let ((a 48271) (b 0) (m 2147483647))
         (modulo (+ (* a x) b) m)
         ))
```

<img src="3-1.assets/image-20240219174247659.png" alt="image-20240219174247659" style="zoom:50%;" />







使用随机数来实现一种称为**蒙特卡罗模拟**。

*Monte Carlo simulation*.

从一个大的集合中随机选择样本实验，然后根据从这些实验结果制表估计的概率进行推断。

The Monte Carlo method consists of choosing sample experiments **at random from a large set** and then making deductions on the basis of the probabilities estimated from tabulating the results of those experiments.

we can approximate  $\pi$ using the fact that $6/\pi^2 $ is the probability that two integers chosen at random will have no factors in common; that is, **that their greatest common divisor will be 1**



（1）大量实验

（2）每次实验选择两个随机数，然后看这两个数的gcd是否为1

（3）得到的概率就可以估计 $\pi$



```lisp
(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))
(define (cesaro-test)
   (= (gcd (rand) (rand)) 1))
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))
```

赋值将随机数生成器的状态**封装在rand过程中**，

**因此随机数生成的细节与程序的其余部分保持独立**。



如果使用 rand-update，而不是 rand ，那么过程描述可以改写如下：

```lisp
(define (estimate-pi trials)
  (sqrt (/ 6 (random-gcd-test trials random-init))))
(define (random-gcd-test trials initial-x)
  (define (iter trials-remaining trials-passed x)
    (let ((x1 (rand-update x)))
      (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)   
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trials-remaining 1)
                     trials-passed
                     x2))))))
  (iter trials 0 initial-x))
```

随机数生成器没有本地状态，random-gcd-test**必须显式地操作随机数x1和x2，并通过迭代循环回收x2作为rand更新的新输入**



我们用**局部状态变量来模拟状态**，我们**用这些变量的赋值来模拟状态的变化**。

所以**赋值语句是必要的，用来模拟状态的变化。**



通过**引入赋值和在局部变量中隐藏状态的技术**，我们能够以一种**更加模块化的方式构建系统**，而**不是通过传递附加参数显式地操纵所有状态**。





