## 3.4 Concurrency: Time Is of the Essence



一旦语言引入了set!，即有了具有local state 的对象，那么会下面的问题：

the loss of referential transparency, giving rise to a thicket of questions about **sameness and change**

the need to abandon the substitution model of evaluation in favor of the more **intricate environment model**

（1）同一性问题不好处理

（2）抛弃替代模型，而是使用环境模型

（3）没有引入set!，那么就所有的过程给定相同的参数，那么结果都是一样的，但是引入了set!，就需要考虑time对结果的影响。

```lisp
(withdraw 25)
;75
(withdraw 25)
;50
```

we are forced to **admit time** into our computational models

Building models in terms of computational objects with local state forces us to **confront time as an essential concept in programming.**



（1）并发更加符合实际

（2）并发速度快

（3）将一个人物切分为多个子部分，每个子部分之间通信少，**那么就会有和处理器数量成比例的速度优势**

（4）并发不好理解，复杂性高



Time is a device that was invented to **keep everything from happening at once**

时间是一种装置，被发明出来是为了防止一切同时发生。



### 3.4.1 The Nature of Time in Concurrent Systems

what is time？

**It is an ordering imposed on events.**



银行有 \$100，A要取  \$10，B要取 \$25

那么可能的序列是：

- \$100 -> \$90 -> \$65
- $100 -> \$75 -> \$65



有问题的语句就是这个 set!

```lisp
(set! balance (- balance amount))
```

(1) accessing the value of the `balance` variable; 

(2) computing the new balance; 

(3) setting `balance` to this new value. 



两个同时执行这个语句的对象，可能会有多种可能的顺序，

由于balance是共享的，那么就有数据竞争。



为了保证一致性，需要设计一些**复杂的保护机制**防止出现问题。



- 几个过程可能**共享一个共同的状态变量**。
- 多个进程可能同时试图操作**共享状态**。
- 在每个过程期间，**每个进程都应该能够像其他进程不存在一样运行指令。**





#### Correct behavior of concurrent programs

我们需要对共享一个变量的进程的set!进行限制：

<img src="3-4.assets/image-20240227140421525.png" alt="image-20240227140421525" style="zoom:67%;" />

上面的就是错误情况。



For distributed banking, it would require the system designer to ensure that only one transaction could proceed at a time. 

**This would be both inefficient and overly conservative.**



（1）如果顺序不同，结果相同，那么限制就弱，不用控制顺序也行。

（2）如果和顺序完全没有关系，那么限制就是最弱的，没有任何限制，随便写。

A program for simulating diffusion (say, **the flow of heat in an object**) might consist of **a large number of processes**, each one representing a small volume of space, that update their values concurrently.

Each process repeatedly changes its value to **the average of its own value and its neighbors' values**.

This algorithm **converges to the right answer** independent of the order in which the operations are done;

there is **no need for any restrictions** on concurrent use of the shared values.

即结果和过程无关，就不需要关注并发带来的问题。



