#lang sicp

; binary tree
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))

; x-dim table
(define (make-table dim same-key? less-key? greater-key?)
  (let ((local-table (list '*table*)))
    (define (key r)
      (car r))
    ; 1-d table(binary tree) lookup 
    (define (assoc given-key records)
      (cond ((null? records) false)
            ((same-key? given-key (key (entry records)))
             (entry records)
             )
            ((less-key? given-key (key (entry records)))
             (assoc given-key (left-branch records))
             )
            ((greater-key? given-key (key (entry records)))
             (assoc given-key (right-branch records))
             )
            )
      )
    ; 1-d table(binary tree) insert
    (define (adjoin-set given-record records)
      (cond ((null? records) (make-tree given-record nil nil))
            ((same-key? (key given-record)
                        (key (entry records)))
             records)
            ((less-key? (key given-record)
                        (key (entry records)))
             (make-tree (entry records) 
                        (adjoin-set given-record (left-branch records))
                        (right-branch records)))
            ((greater-key? (key given-record)
                           (key (entry records)))
             (make-tree (entry records)
                        (left-branch records)
                        (adjoin-set given-record (right-branch records)))))
      )
    
    (define (lookup . key)
      (define (lookup-iter key-list table)
        (if (null? key-list)
            (cdr table)
            (let* ((key-i (car key-list))
                   (sub-table (assoc key-i (cdr table)))
                   )
              (if sub-table
                  (lookup-iter (cdr key-list) sub-table)
                  false
                  )
              )
            )
        )
      (let ((key-num (length key)))
        (if (not (= dim key-num))
            (error "lookup : pass " dim "keys, you only pass " key-num "keys")
            )
        )
      (lookup-iter key local-table)
      )

    (define (insert! . key-value)  
      (let* ((key-last nil)
             (value nil)
             (new-pair nil)
             (key-num (- (length key-value) 1))
             )
        (define (split-key-value x)
          (if (not (null? x))
              (begin
                (split-key-value (cdr x))
                (cond ((null? (cdr x)) (set! value (car x)))
                      ((null? (cddr x)) (if (null? key-last) (set! key-last (car x))))
                      ((null? (cdddr x)) (set-cdr! x nil))
                      )
                )
              )
        )
        
        ; get key-prev key-last value
        (if (not (= key-num dim))
            (error "insert : pass " dim "keys, you only pass " key-num "keys")
            )
        (split-key-value key-value)
        (set! new-pair (cons key-last value))
        (if (= key-num 1)
            (set! key-value nil); bug!!!
            )

        ; helper (pay attention to)!!!
        (define (make-kdim-table key-p)
          (define (kdim-table key-list)
            (if (null? key-list)
                new-pair
                (cons (car key-list)
                      (make-tree (kdim-table (cdr key-list)) nil nil) )
                )
            )
          (kdim-table key-p)
          )
        (define (insert!-iter key-list table)
          (if (null? key-list)
              ; find the last key
              (let ((record (assoc key-last (cdr table))))
                (if record
                    (set-cdr! record value)
                    (set-cdr! table
                              (adjoin-set new-pair (cdr table))
                              ;(cons new-pair
                              ;      (cdr table))
                            )
                    )
                )
              ; otherwise
              (let* ((key-i (car key-list))
                     (sub-table (assoc key-i (cdr table)))
                     )
                (if sub-table
                    (insert!-iter (cdr key-list) sub-table)
                    ;(set-cdr! table (cons (make-kdim-table key-list) (cdr table)))
                    (set-cdr! table (adjoin-set (make-kdim-table key-list) (cdr table)))
                    )
                )
              )
          )
        (insert!-iter key-value local-table)
        'ok
        ))
    (define (print-proc)
      (display (cdr local-table))
      (newline)
      )
  
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            ((eq? m 'print-proc) print-proc)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define dim 1)
(define operation-table (make-table dim equal? < >)) 
(define get (operation-table 'lookup-proc)) 
(define put (operation-table 'insert-proc!))
(define print-table (operation-table 'print-proc))

(put 10 'hello)
(put 12 'world)
(put 13 'hhho)
(get 12)
(get 13)
(get 10)
(get 15)