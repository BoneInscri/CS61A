#lang sicp
(define (square x) (* x x))

(define (divides? a b)
  (= (remainder b a) 0))

(define (search-for-primes next-test lower upper count)
  (define (timed-prime-test n)
    (define (report-prime elapsed-time)
      (newline)
      (display n)
      (display " *** ")
      (display elapsed-time)
      #t)
    (define (start-prime-test start-time)
      (define (prime?)
        (define (smallest-divisor)
          (define (find-divisor test-divisor)
            (cond 
              ((> (square test-divisor) n) n)
              ((divides? test-divisor n) test-divisor)
              (else (find-divisor (next-test test-divisor) ))))
          (find-divisor 2))
        (= n (smallest-divisor)))
      (if (prime?)
          (report-prime (- (runtime) start-time))
          #f))
    (start-prime-test (runtime)))
  (define (iter n count)
    (cond ((and (<= n upper) (> count 0))
           (if (timed-prime-test n)
               (iter (+ n 2) (- count 1))
               (iter (+ n 2) count))
           )
          (else (display "\nOver"))
          )) 
  (iter (if (odd? lower) lower (+ lower 1)) count))

; test
(define (next-plusone value) (+ 1 value))
(define (next-plustwo value) (if (= value 2) 3 (+ 2 value)))

(display "test for old start")
(search-for-primes next-plusone 1000 1100 3)
(search-for-primes next-plusone 10000 11000 3)
(search-for-primes next-plusone 100000 110000 3)
(search-for-primes next-plusone 1000000 1100000 3)
(search-for-primes next-plusone 10000000 11000000 3)
(search-for-primes next-plusone 100000000 110000000 3)
(display "test for old end\n")

(display "test for new start")
(search-for-primes next-plustwo 1000 1100 3)
(search-for-primes next-plustwo 10000 11000 3)
(search-for-primes next-plustwo 100000 110000 3)
(search-for-primes next-plustwo 1000000 1100000 3)
(search-for-primes next-plustwo 10000000 11000000 3)
(search-for-primes next-plustwo 100000000 110000000 3)
(display "test for new end\n")